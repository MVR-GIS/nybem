---
title: "ecorest_raster_conversion"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{ecorest_raster_conversion}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

The purpose of this document is to evaluate the `ecorest` R package to determine the steps needed to refactor `ecorest` to support habitat suitability model metric inputs in raster format. `ecorest` was originally designed to support single-value metric inputs. The approach will be to create new refactored functions that implement raster support. 


## Data Frame: `HSImetadata` 
Stores HSI model functional forms. 

### Structure
* Data frame in wide format. 
* Rows represent models of a species-lifestage.
* Columns are model attributes. 

### Purpose
* Store model attributes to support queries and provide documentation ("model", "submodel", "species", "geography", "ecosystem", "documentation", "note", "website")
* Store suitability metric names ("SIV1" - "SIV22")
* Store model component equations as a character string ("CF", "CC", "CCF", "CWF", "CW", "CCB", "CCN", "CWQ", "CR", "CCR", "CD", "COT", "CL", "CEL", "CE", "CJ", "CFr", "CS", "CA", "CI", "CNI", "CWFC", "CT", "CJA")
* Store the overall HSI model equation as a character string ("Eqtn"). This expression is commonly composed of the results of components. 
* Provide a data structure that can be queried to facilitate model expression evaluation. 
* Model equations stored as character strings are converted to expressions and then evaluated. 

### Depends  
* Model data entry from source references. 

### Supports
* `HSIeqtn`

### Raster Support
* Check if model component equation and overall HSI model equation expressions can be evaluated with raster input. 
* In other words, determine if SIV inputs can be either single value or raster. Do component equations support by input types?  
* According to [`raster::Arith-methods`](https://search.r-project.org/CRAN/refmans/raster/html/Arith-methods.html), standard arithmetic operators for computations with `Raster*` objects and numeric values are: +, -, *, /, ^, %%, %/%, 
* According to [`raster::Math-methods`](https://search.r-project.org/CRAN/refmans/raster/html/Math-methods.html), generic mathematical functions that can be used with a `Raster*` object as argument:"abs", "sign", "sqrt", "ceiling", "floor", "trunc", "cummax", "cummin", "cumprod", "cumsum", "log", "log10", "log2", "log1p", "acos", "acosh", "asin", "asinh", "atan", "atanh", "exp", "expm1", "cos", "cosh", "sin", "sinh", "tan", "tanh"
* However, this does not appear to be complete list. Several functions not on this list appear to correctly handle `Raster*` inputs (e.g., "min", "max", "ifelse"). 
* According to `raster::Logic-methods` the following logical (boolean) operators are available for computations with `Raster*` objects: &, |, and !. 
* The model equations routinely use functions not in the list, primarily <, >, >=, <=, ==. When logical operators are used with rasters, a raster object containing TRUE/FALSE is returned, but most functions (i.e., "ifelse") expect a single logical, throwing an error. 
* Therefore, raster-safe versions of functions will need to be created. 
* A raster-safe `nybem::ifelse` has been created as a replacement for `base::ifelse` that seems to be working. 
* As an alternative to direct arithmetic and math support for rasters discussed above, the functions`raster::calc` (single raster input) and `raster::overlay` (multiple raster input) could be used. 
* `calc` and `overlay` have enhanced support for large rasters. However, raster math seems to be working efficiently (i.e., all layers can easily be stored in memory) for large study areas (e.g., NJ extent with 30m pixel resolution). 
* If raster math cannot be used, `HSIeqtn` will need to be adapted to deferentially handle single-value SIV input using the existing method and rasters using the `calc` or `overlay` method. However, preparing input for `calc` and `overlay` will require a complete rewrite of expression evaluation in `HSIeqtn`. 
* Determine if HSI equations originally designed for single-value input even make sense when raster input is provided. Are the existing equations valid for rasters? Do they need to be adapted? 
* For example, the equation "ifelse(CA < CL, CA, (CL * CA)^(1/2))", evaluated in the raster case would result in a raster with areas where CA < CL being equal to CA, while CA !< CL will equal (CL * CA)^(1/2). Is that what is expected under the spirit of the original HSI? 


## List of Data Frames: `HSImodels` 
Stores HSI model metric and suitability index values. 

## Structure
* Named list of data frames.
* Named list elements represent a model of a species-lifestage represented as a data frame. 
* List element names match `HSImetedata$models`. 
* Each model data frame contains columns of model metrics and rows representing model metric value breakpoints. 
* Columns occur as pairs with the first element of the pair representing the metric (the value measure in the real world) and the second element represents the suitability index value (SIV, 0-1) at the metric value expressed in the matching metric column. 
* Columns are named based on the metric that they represent. 
* The metric suitability index column is usually suffixed with "SIV" to distinguish it from the metric column. 

### Purpose
* Store model metric names (as column names).
* Store model metric breakpoints (as rows). 
* Store model metric real world values (in a column with the metric name)
* Store model metric suitability index values (in a column with the metric name suffixed with "SIV")
* The metric column and its suitability index value column must occur in column pairs. 
* Provide a data structure that can be queried to facilitate model evaluation. 

### Depends
* Model data entry from source references. 

### Supports
* `SIcalc`

### Raster Support
* Continuous metrics with numeric breakpoints are well suited to calculating rasters. 
* Categorical metrics with factor breakpoints require special treatment. `raster::RasterLayer` objects set to store factors, use to integer numeric values for each level and then use a factor lookup to return the categorical class. 

## Function: `SIcalc`
Converts observed metric values into suitability index (SI) values.  

### Purpose
* Converts observed metric values into suitability index values. 
* Must be able to handle single value observations or raster observations. 
* Must be able to calculate SI values for all of the metrics in a model. 

### Depends
* `HSImodels`

### Supports
* `HSIeqtn`

### Raster Support
* Extracting the vector of values from a raster allows the SI calculations to be handled the same as single element vector. 
* Continuous metrics with numeric breakpoints are well suited to calculating SI values using the `stats::approx` function from rasters (after extracting a vector of values). The interpolated continuous values are then assigned back to the raster. 
* Categorical metrics pose some challenges for raster adaptation as categorical rasters (factors) are stored as numeric and the raster attribute table stores the class name. 


## Function: `HSIeqtn`
Calculate HSI values for a model. 

### Purpose
* Calculate HSI values for a model. 
* Apply the input suitability index values to the model equation. 

### Depends
* `SICalc`
* `HSImetadata`

### Raster Support
* Determine if rasters are supported by all functional forms specified in `HSImetadata`

## Function: `HSIplotter`
Visualize HSI model metric values and their suitability index values. 

### Purpose
* Visualize HSI model metric values and their suitability index values. 
* Simplify quality assurance. 
* Automate visualization and reporting. 

### Depends
* `HSImodels`

### Supports
* NA

### Raster Support
* NA
